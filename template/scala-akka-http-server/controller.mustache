package {{invokerPackage}}

{{#apiInfo}}{{#apis}}{{#operations}}import {{package}}.{{classname}}
{{/operations}}{{/apis}}{{/apiInfo}}
import akka.actor.ActorSystem
import akka.http.scaladsl.model.{ContentTypes, HttpEntity, HttpMethods, HttpRequest}
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server.Route
import com.github.mustachejava.DefaultMustacheFactory
import org.openapi4j.core.validation.ValidationException
import org.openapi4j.operation.validator.model.Request.Method
import org.openapi4j.operation.validator.model.impl.{Body, DefaultRequest}
import org.openapi4j.operation.validator.validation.RequestValidator
import org.openapi4j.parser.OpenApi3Parser

import java.io.{BufferedWriter, File, FileWriter, StringWriter}
import java.nio.file.{Files, Paths}
import scala.collection.mutable
import scala.concurrent.duration._
import scala.jdk.CollectionConverters._
import scala.util.{Failure, Success, Try}

class Controller({{#apiInfo}}{{#apis}}{{#operations}}{{classVarName}}: {{classname}}{{^-last}}, {{/-last}}{{/operations}}{{/apis}}{{/apiInfo}}, validationExceptionToRoute: Option[ValidationException => Route] = None)(implicit system: ActorSystem) {
val interfaceVersion: String = buildinfo.BuildInfo.interfaceVersion
private val mf = new DefaultMustacheFactory

  def compileFile(rootDir: File, fileName: String, parentRelativePath: Option[String]): File = {
    val writer =
      mf.compile(s"${parentRelativePath.map(d => s"$d/").getOrElse("")}$fileName")
        .execute(new StringWriter(), mutable.HashMap("version" -> interfaceVersion).asJava)
        .asInstanceOf[StringWriter]
    writer.flush()
    writer.close()

    val tmpFile = parentRelativePath match {
      case Some(dir) =>
        val specDirPath = Paths.get(s"${rootDir.getAbsolutePath}/$dir")
        val specDir =
          if (!Files.exists(specDirPath)) Files.createDirectories(specDirPath).toFile
          else specDirPath.toFile
        new File(specDir, fileName)
      case None => new File(rootDir, fileName)
    }

    tmpFile.deleteOnExit()

    val w = new BufferedWriter(new FileWriter(tmpFile))
    w.write(writer.toString)
    w.close()

    tmpFile
  }

  def compileDir(outputDir: File, elem: File, parentRelativePath: Option[String]): Unit = {
    if (elem.exists) {
      if (elem.isDirectory) {
        elem.listFiles.toList.map { file =>
          compileDir(outputDir, file, Some(s"${parentRelativePath.map(_ + "/").getOrElse("")}${elem.getName}"))
        }
      } else if (elem.isFile) {
        compileFile(outputDir, elem.getName, parentRelativePath)
      }
    }
  }

  val tempDir: File = Files.createTempDirectory("apiInterface").toFile
  tempDir.deleteOnExit()
  val specsDirName          = "specs"
  val sourceDirPath: String = getClass.getResource(s"/$specsDirName").getPath
  val specsDir              = new File(sourceDirPath)
  compileDir(tempDir, specsDir, None)

  val tmpFile: File = compileFile(tempDir, "interface-specification.yml", None)

private val api = new OpenApi3Parser().parse(tmpFile, true)
private val validator = new RequestValidator(api)
private val strictnessTimeout = FiniteDuration({{entityStrictnessTimeout}}, SECONDS)
private val validationsWhitelist: List[String] = List("swagger-ui", "build-info")

def validationFunction(httpRequest: HttpRequest)(route: Route): Route = {
if (!(validationExceptionToRoute.isDefined && !validationsWhitelist.exists(httpRequest.uri.toString.contains(_))))
route
else {
val builder = new DefaultRequest.Builder(httpRequest.uri.toString(), httpRequest.method match {
case HttpMethods.POST =>
Method.POST
case HttpMethods.GET =>
Method.GET
case HttpMethods.PUT =>
Method.PUT
case HttpMethods.DELETE =>
Method.DELETE
case HttpMethods.HEAD =>
Method.HEAD
case HttpMethods.OPTIONS =>
Method.OPTIONS
case HttpMethods.PATCH =>
Method.PATCH
case HttpMethods.TRACE =>
Method.TRACE
case _ =>
Method.GET
})
val entity = httpRequest.entity.asInstanceOf[HttpEntity.Strict]
val contentType = entity.getContentType().toString
val requestHeaders = ("Content-Type", contentType) :: httpRequest.
headers.
map(
header =>
(header.name(), header.value)
).
toList

val headers = (("Content-Type", contentType) :: requestHeaders).map(p => (p._1, Seq(p._2).asJava: java.util.Collection[String])).toMap.asJava

val validatingRequest = builder.body(Body.from(entity.data.utf8String)).headers(headers).build()
Try(validator.validate(validatingRequest)) match {
case Failure(e: ValidationException) =>
validationExceptionToRoute.fold[Route](complete((400, e.getMessage)))(_ (e))
case Failure(e) =>
throw e
case Success(_) =>
route
}
}
}

/**
* Exposes build information of this project.
*/
def getBuildInfo: Route =
path("{{projectName}}" / "build-info") {
get {
complete(HttpEntity(ContentTypes.`application/json`, buildinfo.BuildInfo.toJson))
}
}

lazy val routes: Route = getBuildInfo ~ pathPrefix("{{projectName}}" / interfaceVersion) {
toStrictEntity(strictnessTimeout) {
extractRequest {
request =>
validationFunction(request){
{{#apiInfo}}{{#apis}}{{#operations}}{{classVarName}}.route {{^-last}} ~ {{/-last}}{{/operations}}{{/apis}}{{/apiInfo}}
}
} ~ getFromResourceDirectory("swagger-ui") ~ getFromFile(tmpFile)
}
}

}